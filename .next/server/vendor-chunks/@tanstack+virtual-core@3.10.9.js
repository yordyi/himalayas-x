"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tanstack+virtual-core@3.10.9";
exports.ids = ["vendor-chunks/@tanstack+virtual-core@3.10.9"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@tanstack+virtual-core@3.10.9/node_modules/@tanstack/virtual-core/dist/esm/index.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tanstack+virtual-core@3.10.9/node_modules/@tanstack/virtual-core/dist/esm/index.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Virtualizer: () => (/* binding */ Virtualizer),\n/* harmony export */   approxEqual: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.approxEqual),\n/* harmony export */   debounce: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce),\n/* harmony export */   defaultKeyExtractor: () => (/* binding */ defaultKeyExtractor),\n/* harmony export */   defaultRangeExtractor: () => (/* binding */ defaultRangeExtractor),\n/* harmony export */   elementScroll: () => (/* binding */ elementScroll),\n/* harmony export */   measureElement: () => (/* binding */ measureElement),\n/* harmony export */   memo: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.memo),\n/* harmony export */   notUndefined: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined),\n/* harmony export */   observeElementOffset: () => (/* binding */ observeElementOffset),\n/* harmony export */   observeElementRect: () => (/* binding */ observeElementRect),\n/* harmony export */   observeWindowOffset: () => (/* binding */ observeWindowOffset),\n/* harmony export */   observeWindowRect: () => (/* binding */ observeWindowRect),\n/* harmony export */   windowScroll: () => (/* binding */ windowScroll)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/.pnpm/@tanstack+virtual-core@3.10.9/node_modules/@tanstack/virtual-core/dist/esm/utils.js\");\n\nconst defaultKeyExtractor = (index)=>index;\nconst defaultRangeExtractor = (range)=>{\n    const start = Math.max(range.startIndex - range.overscan, 0);\n    const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n    const arr = [];\n    for(let i = start; i <= end; i++){\n        arr.push(i);\n    }\n    return arr;\n};\nconst observeElementRect = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const targetWindow = instance.targetWindow;\n    if (!targetWindow) {\n        return;\n    }\n    const handler = (rect)=>{\n        const { width, height } = rect;\n        cb({\n            width: Math.round(width),\n            height: Math.round(height)\n        });\n    };\n    handler(element.getBoundingClientRect());\n    if (!targetWindow.ResizeObserver) {\n        return ()=>{};\n    }\n    const observer = new targetWindow.ResizeObserver((entries)=>{\n        const entry = entries[0];\n        if (entry == null ? void 0 : entry.borderBoxSize) {\n            const box = entry.borderBoxSize[0];\n            if (box) {\n                handler({\n                    width: box.inlineSize,\n                    height: box.blockSize\n                });\n                return;\n            }\n        }\n        handler(element.getBoundingClientRect());\n    });\n    observer.observe(element, {\n        box: \"border-box\"\n    });\n    return ()=>{\n        observer.unobserve(element);\n    };\n};\nconst addEventListenerOptions = {\n    passive: true\n};\nconst observeWindowRect = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const handler = ()=>{\n        cb({\n            width: element.innerWidth,\n            height: element.innerHeight\n        });\n    };\n    handler();\n    element.addEventListener(\"resize\", handler, addEventListenerOptions);\n    return ()=>{\n        element.removeEventListener(\"resize\", handler);\n    };\n};\nconst supportsScrollend =  true ? true : 0;\nconst observeElementOffset = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const targetWindow = instance.targetWindow;\n    if (!targetWindow) {\n        return;\n    }\n    let offset = 0;\n    const fallback = instance.options.useScrollendEvent && supportsScrollend ? ()=>void 0 : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce)(targetWindow, ()=>{\n        cb(offset, false);\n    }, instance.options.isScrollingResetDelay);\n    const createHandler = (isScrolling)=>()=>{\n            const { horizontal, isRtl } = instance.options;\n            offset = horizontal ? element[\"scrollLeft\"] * (isRtl && -1 || 1) : element[\"scrollTop\"];\n            fallback();\n            cb(offset, isScrolling);\n        };\n    const handler = createHandler(true);\n    const endHandler = createHandler(false);\n    endHandler();\n    element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n    return ()=>{\n        element.removeEventListener(\"scroll\", handler);\n        element.removeEventListener(\"scrollend\", endHandler);\n    };\n};\nconst observeWindowOffset = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const targetWindow = instance.targetWindow;\n    if (!targetWindow) {\n        return;\n    }\n    let offset = 0;\n    const fallback = instance.options.useScrollendEvent && supportsScrollend ? ()=>void 0 : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce)(targetWindow, ()=>{\n        cb(offset, false);\n    }, instance.options.isScrollingResetDelay);\n    const createHandler = (isScrolling)=>()=>{\n            offset = element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"];\n            fallback();\n            cb(offset, isScrolling);\n        };\n    const handler = createHandler(true);\n    const endHandler = createHandler(false);\n    endHandler();\n    element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n    return ()=>{\n        element.removeEventListener(\"scroll\", handler);\n        element.removeEventListener(\"scrollend\", endHandler);\n    };\n};\nconst measureElement = (element, entry, instance)=>{\n    if (entry == null ? void 0 : entry.borderBoxSize) {\n        const box = entry.borderBoxSize[0];\n        if (box) {\n            const size = Math.round(box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]);\n            return size;\n        }\n    }\n    return Math.round(element.getBoundingClientRect()[instance.options.horizontal ? \"width\" : \"height\"]);\n};\nconst windowScroll = (offset, { adjustments = 0, behavior }, instance)=>{\n    var _a, _b;\n    const toOffset = offset + adjustments;\n    (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n        [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n        behavior\n    });\n};\nconst elementScroll = (offset, { adjustments = 0, behavior }, instance)=>{\n    var _a, _b;\n    const toOffset = offset + adjustments;\n    (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n        [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n        behavior\n    });\n};\nclass Virtualizer {\n    constructor(opts){\n        this.unsubs = [];\n        this.scrollElement = null;\n        this.targetWindow = null;\n        this.isScrolling = false;\n        this.scrollToIndexTimeoutId = null;\n        this.measurementsCache = [];\n        this.itemSizeCache = /* @__PURE__ */ new Map();\n        this.pendingMeasuredCacheIndexes = [];\n        this.scrollRect = null;\n        this.scrollOffset = null;\n        this.scrollDirection = null;\n        this.scrollAdjustments = 0;\n        this.elementsCache = /* @__PURE__ */ new Map();\n        this.observer = /* @__PURE__ */ (()=>{\n            let _ro = null;\n            const get = ()=>{\n                if (_ro) {\n                    return _ro;\n                }\n                if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n                    return null;\n                }\n                return _ro = new this.targetWindow.ResizeObserver((entries)=>{\n                    entries.forEach((entry)=>{\n                        this._measureElement(entry.target, entry);\n                    });\n                });\n            };\n            return {\n                disconnect: ()=>{\n                    var _a;\n                    (_a = get()) == null ? void 0 : _a.disconnect();\n                    _ro = null;\n                },\n                observe: (target)=>{\n                    var _a;\n                    return (_a = get()) == null ? void 0 : _a.observe(target, {\n                        box: \"border-box\"\n                    });\n                },\n                unobserve: (target)=>{\n                    var _a;\n                    return (_a = get()) == null ? void 0 : _a.unobserve(target);\n                }\n            };\n        })();\n        this.range = null;\n        this.setOptions = (opts2)=>{\n            Object.entries(opts2).forEach(([key, value])=>{\n                if (typeof value === \"undefined\") delete opts2[key];\n            });\n            this.options = {\n                debug: false,\n                initialOffset: 0,\n                overscan: 1,\n                paddingStart: 0,\n                paddingEnd: 0,\n                scrollPaddingStart: 0,\n                scrollPaddingEnd: 0,\n                horizontal: false,\n                getItemKey: defaultKeyExtractor,\n                rangeExtractor: defaultRangeExtractor,\n                onChange: ()=>{},\n                measureElement,\n                initialRect: {\n                    width: 0,\n                    height: 0\n                },\n                scrollMargin: 0,\n                gap: 0,\n                indexAttribute: \"data-index\",\n                initialMeasurementsCache: [],\n                lanes: 1,\n                isScrollingResetDelay: 150,\n                enabled: true,\n                isRtl: false,\n                useScrollendEvent: true,\n                ...opts2\n            };\n        };\n        this.notify = (sync)=>{\n            var _a, _b;\n            (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n        };\n        this.maybeNotify = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>{\n            this.calculateRange();\n            return [\n                this.isScrolling,\n                this.range ? this.range.startIndex : null,\n                this.range ? this.range.endIndex : null\n            ];\n        }, (isScrolling)=>{\n            this.notify(isScrolling);\n        }, {\n            key:  true && \"maybeNotify\",\n            debug: ()=>this.options.debug,\n            initialDeps: [\n                this.isScrolling,\n                this.range ? this.range.startIndex : null,\n                this.range ? this.range.endIndex : null\n            ]\n        });\n        this.cleanup = ()=>{\n            this.unsubs.filter(Boolean).forEach((d)=>d());\n            this.unsubs = [];\n            this.observer.disconnect();\n            this.scrollElement = null;\n            this.targetWindow = null;\n        };\n        this._didMount = ()=>{\n            return ()=>{\n                this.cleanup();\n            };\n        };\n        this._willUpdate = ()=>{\n            var _a;\n            const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;\n            if (this.scrollElement !== scrollElement) {\n                this.cleanup();\n                if (!scrollElement) {\n                    this.maybeNotify();\n                    return;\n                }\n                this.scrollElement = scrollElement;\n                if (this.scrollElement && \"ownerDocument\" in this.scrollElement) {\n                    this.targetWindow = this.scrollElement.ownerDocument.defaultView;\n                } else {\n                    this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;\n                }\n                this.elementsCache.forEach((cached)=>{\n                    this.observer.observe(cached);\n                });\n                this._scrollToOffset(this.getScrollOffset(), {\n                    adjustments: void 0,\n                    behavior: void 0\n                });\n                this.unsubs.push(this.options.observeElementRect(this, (rect)=>{\n                    this.scrollRect = rect;\n                    this.maybeNotify();\n                }));\n                this.unsubs.push(this.options.observeElementOffset(this, (offset, isScrolling)=>{\n                    this.scrollAdjustments = 0;\n                    this.scrollDirection = isScrolling ? this.getScrollOffset() < offset ? \"forward\" : \"backward\" : null;\n                    this.scrollOffset = offset;\n                    this.isScrolling = isScrolling;\n                    this.maybeNotify();\n                }));\n            }\n        };\n        this.getSize = ()=>{\n            if (!this.options.enabled) {\n                this.scrollRect = null;\n                return 0;\n            }\n            this.scrollRect = this.scrollRect ?? this.options.initialRect;\n            return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n        };\n        this.getScrollOffset = ()=>{\n            if (!this.options.enabled) {\n                this.scrollOffset = null;\n                return 0;\n            }\n            this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === \"function\" ? this.options.initialOffset() : this.options.initialOffset);\n            return this.scrollOffset;\n        };\n        this.getFurthestMeasurement = (measurements, index)=>{\n            const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n            const furthestMeasurements = /* @__PURE__ */ new Map();\n            for(let m = index - 1; m >= 0; m--){\n                const measurement = measurements[m];\n                if (furthestMeasurementsFound.has(measurement.lane)) {\n                    continue;\n                }\n                const previousFurthestMeasurement = furthestMeasurements.get(measurement.lane);\n                if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n                    furthestMeasurements.set(measurement.lane, measurement);\n                } else if (measurement.end < previousFurthestMeasurement.end) {\n                    furthestMeasurementsFound.set(measurement.lane, true);\n                }\n                if (furthestMeasurementsFound.size === this.options.lanes) {\n                    break;\n                }\n            }\n            return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b)=>{\n                if (a.end === b.end) {\n                    return a.index - b.index;\n                }\n                return a.end - b.end;\n            })[0] : void 0;\n        };\n        this.getMeasurementOptions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.options.count,\n                this.options.paddingStart,\n                this.options.scrollMargin,\n                this.options.getItemKey,\n                this.options.enabled\n            ], (count, paddingStart, scrollMargin, getItemKey, enabled)=>{\n            this.pendingMeasuredCacheIndexes = [];\n            return {\n                count,\n                paddingStart,\n                scrollMargin,\n                getItemKey,\n                enabled\n            };\n        }, {\n            key: false\n        });\n        this.getMeasurements = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.getMeasurementOptions(),\n                this.itemSizeCache\n            ], ({ count, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache)=>{\n            if (!enabled) {\n                this.measurementsCache = [];\n                this.itemSizeCache.clear();\n                return [];\n            }\n            if (this.measurementsCache.length === 0) {\n                this.measurementsCache = this.options.initialMeasurementsCache;\n                this.measurementsCache.forEach((item)=>{\n                    this.itemSizeCache.set(item.key, item.size);\n                });\n            }\n            const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n            this.pendingMeasuredCacheIndexes = [];\n            const measurements = this.measurementsCache.slice(0, min);\n            for(let i = min; i < count; i++){\n                const key = getItemKey(i);\n                const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n                const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n                const measuredSize = itemSizeCache.get(key);\n                const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n                const end = start + size;\n                const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n                measurements[i] = {\n                    index: i,\n                    start,\n                    size,\n                    end,\n                    key,\n                    lane\n                };\n            }\n            this.measurementsCache = measurements;\n            return measurements;\n        }, {\n            key:  true && \"getMeasurements\",\n            debug: ()=>this.options.debug\n        });\n        this.calculateRange = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.getMeasurements(),\n                this.getSize(),\n                this.getScrollOffset()\n            ], (measurements, outerSize, scrollOffset)=>{\n            return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n                measurements,\n                outerSize,\n                scrollOffset\n            }) : null;\n        }, {\n            key:  true && \"calculateRange\",\n            debug: ()=>this.options.debug\n        });\n        this.getIndexes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.options.rangeExtractor,\n                this.calculateRange(),\n                this.options.overscan,\n                this.options.count\n            ], (rangeExtractor, range, overscan, count)=>{\n            return range === null ? [] : rangeExtractor({\n                startIndex: range.startIndex,\n                endIndex: range.endIndex,\n                overscan,\n                count\n            });\n        }, {\n            key:  true && \"getIndexes\",\n            debug: ()=>this.options.debug\n        });\n        this.indexFromElement = (node)=>{\n            const attributeName = this.options.indexAttribute;\n            const indexStr = node.getAttribute(attributeName);\n            if (!indexStr) {\n                console.warn(`Missing attribute name '${attributeName}={index}' on measured element.`);\n                return -1;\n            }\n            return parseInt(indexStr, 10);\n        };\n        this._measureElement = (node, entry)=>{\n            const index = this.indexFromElement(node);\n            const item = this.measurementsCache[index];\n            if (!item) {\n                return;\n            }\n            const key = item.key;\n            const prevNode = this.elementsCache.get(key);\n            if (prevNode !== node) {\n                if (prevNode) {\n                    this.observer.unobserve(prevNode);\n                }\n                this.observer.observe(node);\n                this.elementsCache.set(key, node);\n            }\n            if (node.isConnected) {\n                this.resizeItem(index, this.options.measureElement(node, entry, this));\n            }\n        };\n        this.resizeItem = (index, size)=>{\n            const item = this.measurementsCache[index];\n            if (!item) {\n                return;\n            }\n            const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n            const delta = size - itemSize;\n            if (delta !== 0) {\n                if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {\n                    if ( true && this.options.debug) {\n                        console.info(\"correction\", delta);\n                    }\n                    this._scrollToOffset(this.getScrollOffset(), {\n                        adjustments: this.scrollAdjustments += delta,\n                        behavior: void 0\n                    });\n                }\n                this.pendingMeasuredCacheIndexes.push(item.index);\n                this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n                this.notify(false);\n            }\n        };\n        this.measureElement = (node)=>{\n            if (!node) {\n                this.elementsCache.forEach((cached, key)=>{\n                    if (!cached.isConnected) {\n                        this.observer.unobserve(cached);\n                        this.elementsCache.delete(key);\n                    }\n                });\n                return;\n            }\n            this._measureElement(node, void 0);\n        };\n        this.getVirtualItems = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.getIndexes(),\n                this.getMeasurements()\n            ], (indexes, measurements)=>{\n            const virtualItems = [];\n            for(let k = 0, len = indexes.length; k < len; k++){\n                const i = indexes[k];\n                const measurement = measurements[i];\n                virtualItems.push(measurement);\n            }\n            return virtualItems;\n        }, {\n            key:  true && \"getVirtualItems\",\n            debug: ()=>this.options.debug\n        });\n        this.getVirtualItemForOffset = (offset)=>{\n            const measurements = this.getMeasurements();\n            if (measurements.length === 0) {\n                return void 0;\n            }\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(measurements[findNearestBinarySearch(0, measurements.length - 1, (index)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(measurements[index]).start, offset)]);\n        };\n        this.getOffsetForAlignment = (toOffset, align)=>{\n            const size = this.getSize();\n            const scrollOffset = this.getScrollOffset();\n            if (align === \"auto\") {\n                if (toOffset <= scrollOffset) {\n                    align = \"start\";\n                } else if (toOffset >= scrollOffset + size) {\n                    align = \"end\";\n                } else {\n                    align = \"start\";\n                }\n            }\n            if (align === \"start\") {\n                toOffset = toOffset;\n            } else if (align === \"end\") {\n                toOffset = toOffset - size;\n            } else if (align === \"center\") {\n                toOffset = toOffset - size / 2;\n            }\n            const scrollSizeProp = this.options.horizontal ? \"scrollWidth\" : \"scrollHeight\";\n            const scrollSize = this.scrollElement ? \"document\" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;\n            const maxOffset = scrollSize - size;\n            return Math.max(Math.min(maxOffset, toOffset), 0);\n        };\n        this.getOffsetForIndex = (index, align = \"auto\")=>{\n            index = Math.max(0, Math.min(index, this.options.count - 1));\n            const item = this.measurementsCache[index];\n            if (!item) {\n                return void 0;\n            }\n            const size = this.getSize();\n            const scrollOffset = this.getScrollOffset();\n            if (align === \"auto\") {\n                if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n                    align = \"end\";\n                } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n                    align = \"start\";\n                } else {\n                    return [\n                        scrollOffset,\n                        align\n                    ];\n                }\n            }\n            const toOffset = align === \"end\" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;\n            return [\n                this.getOffsetForAlignment(toOffset, align),\n                align\n            ];\n        };\n        this.isDynamicMode = ()=>this.elementsCache.size > 0;\n        this.cancelScrollToIndex = ()=>{\n            if (this.scrollToIndexTimeoutId !== null && this.targetWindow) {\n                this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId);\n                this.scrollToIndexTimeoutId = null;\n            }\n        };\n        this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {})=>{\n            this.cancelScrollToIndex();\n            if (behavior === \"smooth\" && this.isDynamicMode()) {\n                console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n            }\n            this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n                adjustments: void 0,\n                behavior\n            });\n        };\n        this.scrollToIndex = (index, { align: initialAlign = \"auto\", behavior } = {})=>{\n            index = Math.max(0, Math.min(index, this.options.count - 1));\n            this.cancelScrollToIndex();\n            if (behavior === \"smooth\" && this.isDynamicMode()) {\n                console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n            }\n            const offsetAndAlign = this.getOffsetForIndex(index, initialAlign);\n            if (!offsetAndAlign) return;\n            const [offset, align] = offsetAndAlign;\n            this._scrollToOffset(offset, {\n                adjustments: void 0,\n                behavior\n            });\n            if (behavior !== \"smooth\" && this.isDynamicMode() && this.targetWindow) {\n                this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(()=>{\n                    this.scrollToIndexTimeoutId = null;\n                    const elementInDOM = this.elementsCache.has(this.options.getItemKey(index));\n                    if (elementInDOM) {\n                        const [latestOffset] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(this.getOffsetForIndex(index, align));\n                        if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.approxEqual)(latestOffset, this.getScrollOffset())) {\n                            this.scrollToIndex(index, {\n                                align,\n                                behavior\n                            });\n                        }\n                    } else {\n                        this.scrollToIndex(index, {\n                            align,\n                            behavior\n                        });\n                    }\n                });\n            }\n        };\n        this.scrollBy = (delta, { behavior } = {})=>{\n            this.cancelScrollToIndex();\n            if (behavior === \"smooth\" && this.isDynamicMode()) {\n                console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n            }\n            this._scrollToOffset(this.getScrollOffset() + delta, {\n                adjustments: void 0,\n                behavior\n            });\n        };\n        this.getTotalSize = ()=>{\n            var _a;\n            const measurements = this.getMeasurements();\n            let end;\n            if (measurements.length === 0) {\n                end = this.options.paddingStart;\n            } else {\n                end = this.options.lanes === 1 ? ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0 : Math.max(...measurements.slice(-this.options.lanes).map((m)=>m.end));\n            }\n            return Math.max(end - this.options.scrollMargin + this.options.paddingEnd, 0);\n        };\n        this._scrollToOffset = (offset, { adjustments, behavior })=>{\n            this.options.scrollToFn(offset, {\n                behavior,\n                adjustments\n            }, this);\n        };\n        this.measure = ()=>{\n            this.itemSizeCache = /* @__PURE__ */ new Map();\n            this.notify(false);\n        };\n        this.setOptions(opts);\n    }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value)=>{\n    while(low <= high){\n        const middle = (low + high) / 2 | 0;\n        const currentValue = getCurrentValue(middle);\n        if (currentValue < value) {\n            low = middle + 1;\n        } else if (currentValue > value) {\n            high = middle - 1;\n        } else {\n            return middle;\n        }\n    }\n    if (low > 0) {\n        return low - 1;\n    } else {\n        return 0;\n    }\n};\nfunction calculateRange({ measurements, outerSize, scrollOffset }) {\n    const count = measurements.length - 1;\n    const getOffset = (index)=>measurements[index].start;\n    const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n    let endIndex = startIndex;\n    while(endIndex < count && measurements[endIndex].end < scrollOffset + outerSize){\n        endIndex++;\n    }\n    return {\n        startIndex,\n        endIndex\n    };\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRhbnN0YWNrK3ZpcnR1YWwtY29yZUAzLjEwLjkvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay92aXJ0dWFsLWNvcmUvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVFO0FBQ3ZFLE1BQU1JLHNCQUFzQixDQUFDQyxRQUFVQTtBQUN2QyxNQUFNQyx3QkFBd0IsQ0FBQ0M7SUFDN0IsTUFBTUMsUUFBUUMsS0FBS0MsR0FBRyxDQUFDSCxNQUFNSSxVQUFVLEdBQUdKLE1BQU1LLFFBQVEsRUFBRTtJQUMxRCxNQUFNQyxNQUFNSixLQUFLSyxHQUFHLENBQUNQLE1BQU1RLFFBQVEsR0FBR1IsTUFBTUssUUFBUSxFQUFFTCxNQUFNUyxLQUFLLEdBQUc7SUFDcEUsTUFBTUMsTUFBTSxFQUFFO0lBQ2QsSUFBSyxJQUFJQyxJQUFJVixPQUFPVSxLQUFLTCxLQUFLSyxJQUFLO1FBQ2pDRCxJQUFJRSxJQUFJLENBQUNEO0lBQ1g7SUFDQSxPQUFPRDtBQUNUO0FBQ0EsTUFBTUcscUJBQXFCLENBQUNDLFVBQVVDO0lBQ3BDLE1BQU1DLFVBQVVGLFNBQVNHLGFBQWE7SUFDdEMsSUFBSSxDQUFDRCxTQUFTO1FBQ1o7SUFDRjtJQUNBLE1BQU1FLGVBQWVKLFNBQVNJLFlBQVk7SUFDMUMsSUFBSSxDQUFDQSxjQUFjO1FBQ2pCO0lBQ0Y7SUFDQSxNQUFNQyxVQUFVLENBQUNDO1FBQ2YsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRSxHQUFHRjtRQUMxQkwsR0FBRztZQUFFTSxPQUFPbkIsS0FBS3FCLEtBQUssQ0FBQ0Y7WUFBUUMsUUFBUXBCLEtBQUtxQixLQUFLLENBQUNEO1FBQVE7SUFDNUQ7SUFDQUgsUUFBUUgsUUFBUVEscUJBQXFCO0lBQ3JDLElBQUksQ0FBQ04sYUFBYU8sY0FBYyxFQUFFO1FBQ2hDLE9BQU8sS0FDUDtJQUNGO0lBQ0EsTUFBTUMsV0FBVyxJQUFJUixhQUFhTyxj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LE1BQU1HLGVBQWVGLGdCQUFnQkM7UUFDckMsSUFBSUMsZUFBZWpILE9BQU87WUFDeEI2RyxNQUFNRyxTQUFTO1FBQ2pCLE9BQU8sSUFBSUMsZUFBZWpILE9BQU87WUFDL0I4RyxPQUFPRSxTQUFTO1FBQ2xCLE9BQU87WUFDTCxPQUFPQTtRQUNUO0lBQ0Y7SUFDQSxJQUFJSCxNQUFNLEdBQUc7UUFDWCxPQUFPQSxNQUFNO0lBQ2YsT0FBTztRQUNMLE9BQU87SUFDVDtBQUNGO0FBQ0EsU0FBU3pGLGVBQWUsRUFDdEJpQixZQUFZLEVBQ1p3QixTQUFTLEVBQ1QzRSxZQUFZLEVBQ2I7SUFDQyxNQUFNcEUsUUFBUXVILGFBQWFrQixNQUFNLEdBQUc7SUFDcEMsTUFBTTJELFlBQVksQ0FBQy9NLFFBQVVrSSxZQUFZLENBQUNsSSxNQUFNLENBQUNHLEtBQUs7SUFDdEQsTUFBTUcsYUFBYTRLLHdCQUF3QixHQUFHdkssT0FBT29NLFdBQVdoSTtJQUNoRSxJQUFJckUsV0FBV0o7SUFDZixNQUFPSSxXQUFXQyxTQUFTdUgsWUFBWSxDQUFDeEgsU0FBUyxDQUFDRixHQUFHLEdBQUd1RSxlQUFlMkUsVUFBVztRQUNoRmhKO0lBQ0Y7SUFDQSxPQUFPO1FBQUVKO1FBQVlJO0lBQVM7QUFDaEM7QUFnQkUsQ0FDRixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oaW1hbGF5YXMteC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srdmlydHVhbC1jb3JlQDMuMTAuOS9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2VzbS9pbmRleC5qcz8zZDA5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlYm91bmNlLCBtZW1vLCBub3RVbmRlZmluZWQsIGFwcHJveEVxdWFsIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmNvbnN0IGRlZmF1bHRLZXlFeHRyYWN0b3IgPSAoaW5kZXgpID0+IGluZGV4O1xuY29uc3QgZGVmYXVsdFJhbmdlRXh0cmFjdG9yID0gKHJhbmdlKSA9PiB7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgocmFuZ2Uuc3RhcnRJbmRleCAtIHJhbmdlLm92ZXJzY2FuLCAwKTtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4ocmFuZ2UuZW5kSW5kZXggKyByYW5nZS5vdmVyc2NhbiwgcmFuZ2UuY291bnQgLSAxKTtcbiAgY29uc3QgYXJyID0gW107XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuICAgIGFyci5wdXNoKGkpO1xuICB9XG4gIHJldHVybiBhcnI7XG59O1xuY29uc3Qgb2JzZXJ2ZUVsZW1lbnRSZWN0ID0gKGluc3RhbmNlLCBjYikgPT4ge1xuICBjb25zdCBlbGVtZW50ID0gaW5zdGFuY2Uuc2Nyb2xsRWxlbWVudDtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRhcmdldFdpbmRvdyA9IGluc3RhbmNlLnRhcmdldFdpbmRvdztcbiAgaWYgKCF0YXJnZXRXaW5kb3cpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGFuZGxlciA9IChyZWN0KSA9PiB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSByZWN0O1xuICAgIGNiKHsgd2lkdGg6IE1hdGgucm91bmQod2lkdGgpLCBoZWlnaHQ6IE1hdGgucm91bmQoaGVpZ2h0KSB9KTtcbiAgfTtcbiAgaGFuZGxlcihlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgaWYgKCF0YXJnZXRXaW5kb3cuUmVzaXplT2JzZXJ2ZXIpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgdGFyZ2V0V2luZG93LlJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgY29uc3QgZW50cnkgPSBlbnRyaWVzWzBdO1xuICAgIGlmIChlbnRyeSA9PSBudWxsID8gdm9pZCAwIDogZW50cnkuYm9yZGVyQm94U2l6ZSkge1xuICAgICAgY29uc3QgYm94ID0gZW50cnkuYm9yZGVyQm94U2l6ZVswXTtcbiAgICAgIGlmIChib3gpIHtcbiAgICAgICAgaGFuZGxlcih7IHdpZHRoOiBib3guaW5saW5lU2l6ZSwgaGVpZ2h0OiBib3guYmxvY2tTaXplIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGhhbmRsZXIoZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHsgYm94OiBcImJvcmRlci1ib3hcIiB9KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7XG4gIH07XG59O1xuY29uc3QgYWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMgPSB7XG4gIHBhc3NpdmU6IHRydWVcbn07XG5jb25zdCBvYnNlcnZlV2luZG93UmVjdCA9IChpbnN0YW5jZSwgY2IpID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgIGNiKHsgd2lkdGg6IGVsZW1lbnQuaW5uZXJXaWR0aCwgaGVpZ2h0OiBlbGVtZW50LmlubmVySGVpZ2h0IH0pO1xuICB9O1xuICBoYW5kbGVyKCk7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVyLCBhZGRFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZXIpO1xuICB9O1xufTtcbmNvbnN0IHN1cHBvcnRzU2Nyb2xsZW5kID0gdHlwZW9mIHdpbmRvdyA9PSBcInVuZGVmaW5lZFwiID8gdHJ1ZSA6IFwib25zY3JvbGxlbmRcIiBpbiB3aW5kb3c7XG5jb25zdCBvYnNlcnZlRWxlbWVudE9mZnNldCA9IChpbnN0YW5jZSwgY2IpID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0YXJnZXRXaW5kb3cgPSBpbnN0YW5jZS50YXJnZXRXaW5kb3c7XG4gIGlmICghdGFyZ2V0V2luZG93KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBvZmZzZXQgPSAwO1xuICBjb25zdCBmYWxsYmFjayA9IGluc3RhbmNlLm9wdGlvbnMudXNlU2Nyb2xsZW5kRXZlbnQgJiYgc3VwcG9ydHNTY3JvbGxlbmQgPyAoKSA9PiB2b2lkIDAgOiBkZWJvdW5jZShcbiAgICB0YXJnZXRXaW5kb3csXG4gICAgKCkgPT4ge1xuICAgICAgY2Iob2Zmc2V0LCBmYWxzZSk7XG4gICAgfSxcbiAgICBpbnN0YW5jZS5vcHRpb25zLmlzU2Nyb2xsaW5nUmVzZXREZWxheVxuICApO1xuICBjb25zdCBjcmVhdGVIYW5kbGVyID0gKGlzU2Nyb2xsaW5nKSA9PiAoKSA9PiB7XG4gICAgY29uc3QgeyBob3Jpem9udGFsLCBpc1J0bCB9ID0gaW5zdGFuY2Uub3B0aW9ucztcbiAgICBvZmZzZXQgPSBob3Jpem9udGFsID8gZWxlbWVudFtcInNjcm9sbExlZnRcIl0gKiAoaXNSdGwgJiYgLTEgfHwgMSkgOiBlbGVtZW50W1wic2Nyb2xsVG9wXCJdO1xuICAgIGZhbGxiYWNrKCk7XG4gICAgY2Iob2Zmc2V0LCBpc1Njcm9sbGluZyk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZXIgPSBjcmVhdGVIYW5kbGVyKHRydWUpO1xuICBjb25zdCBlbmRIYW5kbGVyID0gY3JlYXRlSGFuZGxlcihmYWxzZSk7XG4gIGVuZEhhbmRsZXIoKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZXIsIGFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsZW5kXCIsIGVuZEhhbmRsZXIsIGFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlcik7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsZW5kXCIsIGVuZEhhbmRsZXIpO1xuICB9O1xufTtcbmNvbnN0IG9ic2VydmVXaW5kb3dPZmZzZXQgPSAoaW5zdGFuY2UsIGNiKSA9PiB7XG4gIGNvbnN0IGVsZW1lbnQgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50O1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGFyZ2V0V2luZG93ID0gaW5zdGFuY2UudGFyZ2V0V2luZG93O1xuICBpZiAoIXRhcmdldFdpbmRvdykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb2Zmc2V0ID0gMDtcbiAgY29uc3QgZmFsbGJhY2sgPSBpbnN0YW5jZS5vcHRpb25zLnVzZVNjcm9sbGVuZEV2ZW50ICYmIHN1cHBvcnRzU2Nyb2xsZW5kID8gKCkgPT4gdm9pZCAwIDogZGVib3VuY2UoXG4gICAgdGFyZ2V0V2luZG93LFxuICAgICgpID0+IHtcbiAgICAgIGNiKG9mZnNldCwgZmFsc2UpO1xuICAgIH0sXG4gICAgaW5zdGFuY2Uub3B0aW9ucy5pc1Njcm9sbGluZ1Jlc2V0RGVsYXlcbiAgKTtcbiAgY29uc3QgY3JlYXRlSGFuZGxlciA9IChpc1Njcm9sbGluZykgPT4gKCkgPT4ge1xuICAgIG9mZnNldCA9IGVsZW1lbnRbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gXCJzY3JvbGxYXCIgOiBcInNjcm9sbFlcIl07XG4gICAgZmFsbGJhY2soKTtcbiAgICBjYihvZmZzZXQsIGlzU2Nyb2xsaW5nKTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlciA9IGNyZWF0ZUhhbmRsZXIodHJ1ZSk7XG4gIGNvbnN0IGVuZEhhbmRsZXIgPSBjcmVhdGVIYW5kbGVyKGZhbHNlKTtcbiAgZW5kSGFuZGxlcigpO1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlciwgYWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxlbmRcIiwgZW5kSGFuZGxlciwgYWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVyKTtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxlbmRcIiwgZW5kSGFuZGxlcik7XG4gIH07XG59O1xuY29uc3QgbWVhc3VyZUVsZW1lbnQgPSAoZWxlbWVudCwgZW50cnksIGluc3RhbmNlKSA9PiB7XG4gIGlmIChlbnRyeSA9PSBudWxsID8gdm9pZCAwIDogZW50cnkuYm9yZGVyQm94U2l6ZSkge1xuICAgIGNvbnN0IGJveCA9IGVudHJ5LmJvcmRlckJveFNpemVbMF07XG4gICAgaWYgKGJveCkge1xuICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgucm91bmQoXG4gICAgICAgIGJveFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyBcImlubGluZVNpemVcIiA6IFwiYmxvY2tTaXplXCJdXG4gICAgICApO1xuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICB9XG4gIHJldHVybiBNYXRoLnJvdW5kKFxuICAgIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl1cbiAgKTtcbn07XG5jb25zdCB3aW5kb3dTY3JvbGwgPSAob2Zmc2V0LCB7XG4gIGFkanVzdG1lbnRzID0gMCxcbiAgYmVoYXZpb3Jcbn0sIGluc3RhbmNlKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHRvT2Zmc2V0ID0gb2Zmc2V0ICsgYWRqdXN0bWVudHM7XG4gIChfYiA9IChfYSA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zY3JvbGxUbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHtcbiAgICBbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gXCJsZWZ0XCIgOiBcInRvcFwiXTogdG9PZmZzZXQsXG4gICAgYmVoYXZpb3JcbiAgfSk7XG59O1xuY29uc3QgZWxlbWVudFNjcm9sbCA9IChvZmZzZXQsIHtcbiAgYWRqdXN0bWVudHMgPSAwLFxuICBiZWhhdmlvclxufSwgaW5zdGFuY2UpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgdG9PZmZzZXQgPSBvZmZzZXQgKyBhZGp1c3RtZW50cztcbiAgKF9iID0gKF9hID0gaW5zdGFuY2Uuc2Nyb2xsRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNjcm9sbFRvKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwge1xuICAgIFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyBcImxlZnRcIiA6IFwidG9wXCJdOiB0b09mZnNldCxcbiAgICBiZWhhdmlvclxuICB9KTtcbn07XG5jbGFzcyBWaXJ0dWFsaXplciB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLnVuc3VicyA9IFtdO1xuICAgIHRoaXMuc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy50YXJnZXRXaW5kb3cgPSBudWxsO1xuICAgIHRoaXMuaXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnNjcm9sbFRvSW5kZXhUaW1lb3V0SWQgPSBudWxsO1xuICAgIHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUgPSBbXTtcbiAgICB0aGlzLml0ZW1TaXplQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzID0gW107XG4gICAgdGhpcy5zY3JvbGxSZWN0ID0gbnVsbDtcbiAgICB0aGlzLnNjcm9sbE9mZnNldCA9IG51bGw7XG4gICAgdGhpcy5zY3JvbGxEaXJlY3Rpb24gPSBudWxsO1xuICAgIHRoaXMuc2Nyb2xsQWRqdXN0bWVudHMgPSAwO1xuICAgIHRoaXMuZWxlbWVudHNDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5vYnNlcnZlciA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgICAgbGV0IF9ybyA9IG51bGw7XG4gICAgICBjb25zdCBnZXQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChfcm8pIHtcbiAgICAgICAgICByZXR1cm4gX3JvO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy50YXJnZXRXaW5kb3cgfHwgIXRoaXMudGFyZ2V0V2luZG93LlJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9ybyA9IG5ldyB0aGlzLnRhcmdldFdpbmRvdy5SZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX21lYXN1cmVFbGVtZW50KGVudHJ5LnRhcmdldCwgZW50cnkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXNjb25uZWN0OiAoKSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIChfYSA9IGdldCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIF9ybyA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIG9ic2VydmU6ICh0YXJnZXQpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgcmV0dXJuIChfYSA9IGdldCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2Eub2JzZXJ2ZSh0YXJnZXQsIHsgYm94OiBcImJvcmRlci1ib3hcIiB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5vYnNlcnZlOiAodGFyZ2V0KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIHJldHVybiAoX2EgPSBnZXQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnVub2JzZXJ2ZSh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCk7XG4gICAgdGhpcy5yYW5nZSA9IG51bGw7XG4gICAgdGhpcy5zZXRPcHRpb25zID0gKG9wdHMyKSA9PiB7XG4gICAgICBPYmplY3QuZW50cmllcyhvcHRzMikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIGRlbGV0ZSBvcHRzMltrZXldO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgICAgaW5pdGlhbE9mZnNldDogMCxcbiAgICAgICAgb3ZlcnNjYW46IDEsXG4gICAgICAgIHBhZGRpbmdTdGFydDogMCxcbiAgICAgICAgcGFkZGluZ0VuZDogMCxcbiAgICAgICAgc2Nyb2xsUGFkZGluZ1N0YXJ0OiAwLFxuICAgICAgICBzY3JvbGxQYWRkaW5nRW5kOiAwLFxuICAgICAgICBob3Jpem9udGFsOiBmYWxzZSxcbiAgICAgICAgZ2V0SXRlbUtleTogZGVmYXVsdEtleUV4dHJhY3RvcixcbiAgICAgICAgcmFuZ2VFeHRyYWN0b3I6IGRlZmF1bHRSYW5nZUV4dHJhY3RvcixcbiAgICAgICAgb25DaGFuZ2U6ICgpID0+IHtcbiAgICAgICAgfSxcbiAgICAgICAgbWVhc3VyZUVsZW1lbnQsXG4gICAgICAgIGluaXRpYWxSZWN0OiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSxcbiAgICAgICAgc2Nyb2xsTWFyZ2luOiAwLFxuICAgICAgICBnYXA6IDAsXG4gICAgICAgIGluZGV4QXR0cmlidXRlOiBcImRhdGEtaW5kZXhcIixcbiAgICAgICAgaW5pdGlhbE1lYXN1cmVtZW50c0NhY2hlOiBbXSxcbiAgICAgICAgbGFuZXM6IDEsXG4gICAgICAgIGlzU2Nyb2xsaW5nUmVzZXREZWxheTogMTUwLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBpc1J0bDogZmFsc2UsXG4gICAgICAgIHVzZVNjcm9sbGVuZEV2ZW50OiB0cnVlLFxuICAgICAgICAuLi5vcHRzMlxuICAgICAgfTtcbiAgICB9O1xuICAgIHRoaXMubm90aWZ5ID0gKHN5bmMpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMpLm9uQ2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGhpcywgc3luYyk7XG4gICAgfTtcbiAgICB0aGlzLm1heWJlTm90aWZ5ID0gbWVtbyhcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVSYW5nZSgpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHRoaXMuaXNTY3JvbGxpbmcsXG4gICAgICAgICAgdGhpcy5yYW5nZSA/IHRoaXMucmFuZ2Uuc3RhcnRJbmRleCA6IG51bGwsXG4gICAgICAgICAgdGhpcy5yYW5nZSA/IHRoaXMucmFuZ2UuZW5kSW5kZXggOiBudWxsXG4gICAgICAgIF07XG4gICAgICB9LFxuICAgICAgKGlzU2Nyb2xsaW5nKSA9PiB7XG4gICAgICAgIHRoaXMubm90aWZ5KGlzU2Nyb2xsaW5nKTtcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFwibWF5YmVOb3RpZnlcIixcbiAgICAgICAgZGVidWc6ICgpID0+IHRoaXMub3B0aW9ucy5kZWJ1ZyxcbiAgICAgICAgaW5pdGlhbERlcHM6IFtcbiAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nLFxuICAgICAgICAgIHRoaXMucmFuZ2UgPyB0aGlzLnJhbmdlLnN0YXJ0SW5kZXggOiBudWxsLFxuICAgICAgICAgIHRoaXMucmFuZ2UgPyB0aGlzLnJhbmdlLmVuZEluZGV4IDogbnVsbFxuICAgICAgICBdXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmNsZWFudXAgPSAoKSA9PiB7XG4gICAgICB0aGlzLnVuc3Vicy5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaCgoZCkgPT4gZCgpKTtcbiAgICAgIHRoaXMudW5zdWJzID0gW107XG4gICAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLnRhcmdldFdpbmRvdyA9IG51bGw7XG4gICAgfTtcbiAgICB0aGlzLl9kaWRNb3VudCA9ICgpID0+IHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHRoaXMuX3dpbGxVcGRhdGUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBzY3JvbGxFbGVtZW50ID0gdGhpcy5vcHRpb25zLmVuYWJsZWQgPyB0aGlzLm9wdGlvbnMuZ2V0U2Nyb2xsRWxlbWVudCgpIDogbnVsbDtcbiAgICAgIGlmICh0aGlzLnNjcm9sbEVsZW1lbnQgIT09IHNjcm9sbEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgIGlmICghc2Nyb2xsRWxlbWVudCkge1xuICAgICAgICAgIHRoaXMubWF5YmVOb3RpZnkoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsRWxlbWVudCAmJiBcIm93bmVyRG9jdW1lbnRcIiBpbiB0aGlzLnNjcm9sbEVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLnRhcmdldFdpbmRvdyA9IHRoaXMuc2Nyb2xsRWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudGFyZ2V0V2luZG93ID0gKChfYSA9IHRoaXMuc2Nyb2xsRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLndpbmRvdykgPz8gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnRzQ2FjaGUuZm9yRWFjaCgoY2FjaGVkKSA9PiB7XG4gICAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKGNhY2hlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zY3JvbGxUb09mZnNldCh0aGlzLmdldFNjcm9sbE9mZnNldCgpLCB7XG4gICAgICAgICAgYWRqdXN0bWVudHM6IHZvaWQgMCxcbiAgICAgICAgICBiZWhhdmlvcjogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVuc3Vicy5wdXNoKFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5vYnNlcnZlRWxlbWVudFJlY3QodGhpcywgKHJlY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICB0aGlzLm1heWJlTm90aWZ5KCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy51bnN1YnMucHVzaChcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub2JzZXJ2ZUVsZW1lbnRPZmZzZXQodGhpcywgKG9mZnNldCwgaXNTY3JvbGxpbmcpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQWRqdXN0bWVudHMgPSAwO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxEaXJlY3Rpb24gPSBpc1Njcm9sbGluZyA/IHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCkgPCBvZmZzZXQgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIiA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSBpc1Njcm9sbGluZztcbiAgICAgICAgICAgIHRoaXMubWF5YmVOb3RpZnkoKTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRTaXplID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZW5hYmxlZCkge1xuICAgICAgICB0aGlzLnNjcm9sbFJlY3QgPSBudWxsO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2Nyb2xsUmVjdCA9IHRoaXMuc2Nyb2xsUmVjdCA/PyB0aGlzLm9wdGlvbnMuaW5pdGlhbFJlY3Q7XG4gICAgICByZXR1cm4gdGhpcy5zY3JvbGxSZWN0W3RoaXMub3B0aW9ucy5ob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl07XG4gICAgfTtcbiAgICB0aGlzLmdldFNjcm9sbE9mZnNldCA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxPZmZzZXQgPSBudWxsO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0gdGhpcy5zY3JvbGxPZmZzZXQgPz8gKHR5cGVvZiB0aGlzLm9wdGlvbnMuaW5pdGlhbE9mZnNldCA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy5vcHRpb25zLmluaXRpYWxPZmZzZXQoKSA6IHRoaXMub3B0aW9ucy5pbml0aWFsT2Zmc2V0KTtcbiAgICAgIHJldHVybiB0aGlzLnNjcm9sbE9mZnNldDtcbiAgICB9O1xuICAgIHRoaXMuZ2V0RnVydGhlc3RNZWFzdXJlbWVudCA9IChtZWFzdXJlbWVudHMsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBmdXJ0aGVzdE1lYXN1cmVtZW50c0ZvdW5kID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IGZ1cnRoZXN0TWVhc3VyZW1lbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGZvciAobGV0IG0gPSBpbmRleCAtIDE7IG0gPj0gMDsgbS0tKSB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW21dO1xuICAgICAgICBpZiAoZnVydGhlc3RNZWFzdXJlbWVudHNGb3VuZC5oYXMobWVhc3VyZW1lbnQubGFuZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2aW91c0Z1cnRoZXN0TWVhc3VyZW1lbnQgPSBmdXJ0aGVzdE1lYXN1cmVtZW50cy5nZXQoXG4gICAgICAgICAgbWVhc3VyZW1lbnQubGFuZVxuICAgICAgICApO1xuICAgICAgICBpZiAocHJldmlvdXNGdXJ0aGVzdE1lYXN1cmVtZW50ID09IG51bGwgfHwgbWVhc3VyZW1lbnQuZW5kID4gcHJldmlvdXNGdXJ0aGVzdE1lYXN1cmVtZW50LmVuZCkge1xuICAgICAgICAgIGZ1cnRoZXN0TWVhc3VyZW1lbnRzLnNldChtZWFzdXJlbWVudC5sYW5lLCBtZWFzdXJlbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVhc3VyZW1lbnQuZW5kIDwgcHJldmlvdXNGdXJ0aGVzdE1lYXN1cmVtZW50LmVuZCkge1xuICAgICAgICAgIGZ1cnRoZXN0TWVhc3VyZW1lbnRzRm91bmQuc2V0KG1lYXN1cmVtZW50LmxhbmUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdXJ0aGVzdE1lYXN1cmVtZW50c0ZvdW5kLnNpemUgPT09IHRoaXMub3B0aW9ucy5sYW5lcykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVydGhlc3RNZWFzdXJlbWVudHMuc2l6ZSA9PT0gdGhpcy5vcHRpb25zLmxhbmVzID8gQXJyYXkuZnJvbShmdXJ0aGVzdE1lYXN1cmVtZW50cy52YWx1ZXMoKSkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBpZiAoYS5lbmQgPT09IGIuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhLmVuZCAtIGIuZW5kO1xuICAgICAgfSlbMF0gOiB2b2lkIDA7XG4gICAgfTtcbiAgICB0aGlzLmdldE1lYXN1cmVtZW50T3B0aW9ucyA9IG1lbW8oXG4gICAgICAoKSA9PiBbXG4gICAgICAgIHRoaXMub3B0aW9ucy5jb3VudCxcbiAgICAgICAgdGhpcy5vcHRpb25zLnBhZGRpbmdTdGFydCxcbiAgICAgICAgdGhpcy5vcHRpb25zLnNjcm9sbE1hcmdpbixcbiAgICAgICAgdGhpcy5vcHRpb25zLmdldEl0ZW1LZXksXG4gICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkXG4gICAgICBdLFxuICAgICAgKGNvdW50LCBwYWRkaW5nU3RhcnQsIHNjcm9sbE1hcmdpbiwgZ2V0SXRlbUtleSwgZW5hYmxlZCkgPT4ge1xuICAgICAgICB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcyA9IFtdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvdW50LFxuICAgICAgICAgIHBhZGRpbmdTdGFydCxcbiAgICAgICAgICBzY3JvbGxNYXJnaW4sXG4gICAgICAgICAgZ2V0SXRlbUtleSxcbiAgICAgICAgICBlbmFibGVkXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IGZhbHNlXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmdldE1lYXN1cmVtZW50cyA9IG1lbW8oXG4gICAgICAoKSA9PiBbdGhpcy5nZXRNZWFzdXJlbWVudE9wdGlvbnMoKSwgdGhpcy5pdGVtU2l6ZUNhY2hlXSxcbiAgICAgICh7IGNvdW50LCBwYWRkaW5nU3RhcnQsIHNjcm9sbE1hcmdpbiwgZ2V0SXRlbUtleSwgZW5hYmxlZCB9LCBpdGVtU2l6ZUNhY2hlKSA9PiB7XG4gICAgICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgICAgIHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUgPSBbXTtcbiAgICAgICAgICB0aGlzLml0ZW1TaXplQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZSA9IHRoaXMub3B0aW9ucy5pbml0aWFsTWVhc3VyZW1lbnRzQ2FjaGU7XG4gICAgICAgICAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICB0aGlzLml0ZW1TaXplQ2FjaGUuc2V0KGl0ZW0ua2V5LCBpdGVtLnNpemUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pbiA9IHRoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzLmxlbmd0aCA+IDAgPyBNYXRoLm1pbiguLi50aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcykgOiAwO1xuICAgICAgICB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcyA9IFtdO1xuICAgICAgICBjb25zdCBtZWFzdXJlbWVudHMgPSB0aGlzLm1lYXN1cmVtZW50c0NhY2hlLnNsaWNlKDAsIG1pbik7XG4gICAgICAgIGZvciAobGV0IGkgPSBtaW47IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gZ2V0SXRlbUtleShpKTtcbiAgICAgICAgICBjb25zdCBmdXJ0aGVzdE1lYXN1cmVtZW50ID0gdGhpcy5vcHRpb25zLmxhbmVzID09PSAxID8gbWVhc3VyZW1lbnRzW2kgLSAxXSA6IHRoaXMuZ2V0RnVydGhlc3RNZWFzdXJlbWVudChtZWFzdXJlbWVudHMsIGkpO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZnVydGhlc3RNZWFzdXJlbWVudCA/IGZ1cnRoZXN0TWVhc3VyZW1lbnQuZW5kICsgdGhpcy5vcHRpb25zLmdhcCA6IHBhZGRpbmdTdGFydCArIHNjcm9sbE1hcmdpbjtcbiAgICAgICAgICBjb25zdCBtZWFzdXJlZFNpemUgPSBpdGVtU2l6ZUNhY2hlLmdldChrZXkpO1xuICAgICAgICAgIGNvbnN0IHNpemUgPSB0eXBlb2YgbWVhc3VyZWRTaXplID09PSBcIm51bWJlclwiID8gbWVhc3VyZWRTaXplIDogdGhpcy5vcHRpb25zLmVzdGltYXRlU2l6ZShpKTtcbiAgICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIHNpemU7XG4gICAgICAgICAgY29uc3QgbGFuZSA9IGZ1cnRoZXN0TWVhc3VyZW1lbnQgPyBmdXJ0aGVzdE1lYXN1cmVtZW50LmxhbmUgOiBpICUgdGhpcy5vcHRpb25zLmxhbmVzO1xuICAgICAgICAgIG1lYXN1cmVtZW50c1tpXSA9IHtcbiAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgbGFuZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZSA9IG1lYXN1cmVtZW50cztcbiAgICAgICAgcmV0dXJuIG1lYXN1cmVtZW50cztcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFwiZ2V0TWVhc3VyZW1lbnRzXCIsXG4gICAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWdcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuY2FsY3VsYXRlUmFuZ2UgPSBtZW1vKFxuICAgICAgKCkgPT4gW3RoaXMuZ2V0TWVhc3VyZW1lbnRzKCksIHRoaXMuZ2V0U2l6ZSgpLCB0aGlzLmdldFNjcm9sbE9mZnNldCgpXSxcbiAgICAgIChtZWFzdXJlbWVudHMsIG91dGVyU2l6ZSwgc2Nyb2xsT2Zmc2V0KSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlID0gbWVhc3VyZW1lbnRzLmxlbmd0aCA+IDAgJiYgb3V0ZXJTaXplID4gMCA/IGNhbGN1bGF0ZVJhbmdlKHtcbiAgICAgICAgICBtZWFzdXJlbWVudHMsXG4gICAgICAgICAgb3V0ZXJTaXplLFxuICAgICAgICAgIHNjcm9sbE9mZnNldFxuICAgICAgICB9KSA6IG51bGw7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBcImNhbGN1bGF0ZVJhbmdlXCIsXG4gICAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWdcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuZ2V0SW5kZXhlcyA9IG1lbW8oXG4gICAgICAoKSA9PiBbXG4gICAgICAgIHRoaXMub3B0aW9ucy5yYW5nZUV4dHJhY3RvcixcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVSYW5nZSgpLFxuICAgICAgICB0aGlzLm9wdGlvbnMub3ZlcnNjYW4sXG4gICAgICAgIHRoaXMub3B0aW9ucy5jb3VudFxuICAgICAgXSxcbiAgICAgIChyYW5nZUV4dHJhY3RvciwgcmFuZ2UsIG92ZXJzY2FuLCBjb3VudCkgPT4ge1xuICAgICAgICByZXR1cm4gcmFuZ2UgPT09IG51bGwgPyBbXSA6IHJhbmdlRXh0cmFjdG9yKHtcbiAgICAgICAgICBzdGFydEluZGV4OiByYW5nZS5zdGFydEluZGV4LFxuICAgICAgICAgIGVuZEluZGV4OiByYW5nZS5lbmRJbmRleCxcbiAgICAgICAgICBvdmVyc2NhbixcbiAgICAgICAgICBjb3VudFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFwiZ2V0SW5kZXhlc1wiLFxuICAgICAgICBkZWJ1ZzogKCkgPT4gdGhpcy5vcHRpb25zLmRlYnVnXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmluZGV4RnJvbUVsZW1lbnQgPSAobm9kZSkgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlTmFtZSA9IHRoaXMub3B0aW9ucy5pbmRleEF0dHJpYnV0ZTtcbiAgICAgIGNvbnN0IGluZGV4U3RyID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICBpZiAoIWluZGV4U3RyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgTWlzc2luZyBhdHRyaWJ1dGUgbmFtZSAnJHthdHRyaWJ1dGVOYW1lfT17aW5kZXh9JyBvbiBtZWFzdXJlZCBlbGVtZW50LmBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlSW50KGluZGV4U3RyLCAxMCk7XG4gICAgfTtcbiAgICB0aGlzLl9tZWFzdXJlRWxlbWVudCA9IChub2RlLCBlbnRyeSkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4RnJvbUVsZW1lbnQobm9kZSk7XG4gICAgICBjb25zdCBpdGVtID0gdGhpcy5tZWFzdXJlbWVudHNDYWNoZVtpbmRleF07XG4gICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5ID0gaXRlbS5rZXk7XG4gICAgICBjb25zdCBwcmV2Tm9kZSA9IHRoaXMuZWxlbWVudHNDYWNoZS5nZXQoa2V5KTtcbiAgICAgIGlmIChwcmV2Tm9kZSAhPT0gbm9kZSkge1xuICAgICAgICBpZiAocHJldk5vZGUpIHtcbiAgICAgICAgICB0aGlzLm9ic2VydmVyLnVub2JzZXJ2ZShwcmV2Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKG5vZGUpO1xuICAgICAgICB0aGlzLmVsZW1lbnRzQ2FjaGUuc2V0KGtleSwgbm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5pc0Nvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLnJlc2l6ZUl0ZW0oaW5kZXgsIHRoaXMub3B0aW9ucy5tZWFzdXJlRWxlbWVudChub2RlLCBlbnRyeSwgdGhpcykpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yZXNpemVJdGVtID0gKGluZGV4LCBzaXplKSA9PiB7XG4gICAgICBjb25zdCBpdGVtID0gdGhpcy5tZWFzdXJlbWVudHNDYWNoZVtpbmRleF07XG4gICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXRlbVNpemUgPSB0aGlzLml0ZW1TaXplQ2FjaGUuZ2V0KGl0ZW0ua2V5KSA/PyBpdGVtLnNpemU7XG4gICAgICBjb25zdCBkZWx0YSA9IHNpemUgLSBpdGVtU2l6ZTtcbiAgICAgIGlmIChkZWx0YSAhPT0gMCkge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRBZGp1c3RTY3JvbGxQb3NpdGlvbk9uSXRlbVNpemVDaGFuZ2UgIT09IHZvaWQgMCA/IHRoaXMuc2hvdWxkQWRqdXN0U2Nyb2xsUG9zaXRpb25Pbkl0ZW1TaXplQ2hhbmdlKGl0ZW0sIGRlbHRhLCB0aGlzKSA6IGl0ZW0uc3RhcnQgPCB0aGlzLmdldFNjcm9sbE9mZnNldCgpICsgdGhpcy5zY3JvbGxBZGp1c3RtZW50cykge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJjb3JyZWN0aW9uXCIsIGRlbHRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fc2Nyb2xsVG9PZmZzZXQodGhpcy5nZXRTY3JvbGxPZmZzZXQoKSwge1xuICAgICAgICAgICAgYWRqdXN0bWVudHM6IHRoaXMuc2Nyb2xsQWRqdXN0bWVudHMgKz0gZGVsdGEsXG4gICAgICAgICAgICBiZWhhdmlvcjogdm9pZCAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXMucHVzaChpdGVtLmluZGV4KTtcbiAgICAgICAgdGhpcy5pdGVtU2l6ZUNhY2hlID0gbmV3IE1hcCh0aGlzLml0ZW1TaXplQ2FjaGUuc2V0KGl0ZW0ua2V5LCBzaXplKSk7XG4gICAgICAgIHRoaXMubm90aWZ5KGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubWVhc3VyZUVsZW1lbnQgPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNDYWNoZS5mb3JFYWNoKChjYWNoZWQsIGtleSkgPT4ge1xuICAgICAgICAgIGlmICghY2FjaGVkLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnVub2JzZXJ2ZShjYWNoZWQpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50c0NhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21lYXN1cmVFbGVtZW50KG5vZGUsIHZvaWQgMCk7XG4gICAgfTtcbiAgICB0aGlzLmdldFZpcnR1YWxJdGVtcyA9IG1lbW8oXG4gICAgICAoKSA9PiBbdGhpcy5nZXRJbmRleGVzKCksIHRoaXMuZ2V0TWVhc3VyZW1lbnRzKCldLFxuICAgICAgKGluZGV4ZXMsIG1lYXN1cmVtZW50cykgPT4ge1xuICAgICAgICBjb25zdCB2aXJ0dWFsSXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgayA9IDAsIGxlbiA9IGluZGV4ZXMubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICBjb25zdCBpID0gaW5kZXhlc1trXTtcbiAgICAgICAgICBjb25zdCBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICAgICAgICB2aXJ0dWFsSXRlbXMucHVzaChtZWFzdXJlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpcnR1YWxJdGVtcztcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFwiZ2V0VmlydHVhbEl0ZW1zXCIsXG4gICAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWdcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuZ2V0VmlydHVhbEl0ZW1Gb3JPZmZzZXQgPSAob2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBtZWFzdXJlbWVudHMgPSB0aGlzLmdldE1lYXN1cmVtZW50cygpO1xuICAgICAgaWYgKG1lYXN1cmVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RVbmRlZmluZWQoXG4gICAgICAgIG1lYXN1cmVtZW50c1tmaW5kTmVhcmVzdEJpbmFyeVNlYXJjaChcbiAgICAgICAgICAwLFxuICAgICAgICAgIG1lYXN1cmVtZW50cy5sZW5ndGggLSAxLFxuICAgICAgICAgIChpbmRleCkgPT4gbm90VW5kZWZpbmVkKG1lYXN1cmVtZW50c1tpbmRleF0pLnN0YXJ0LFxuICAgICAgICAgIG9mZnNldFxuICAgICAgICApXVxuICAgICAgKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0T2Zmc2V0Rm9yQWxpZ25tZW50ID0gKHRvT2Zmc2V0LCBhbGlnbikgPT4ge1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5nZXRTY3JvbGxPZmZzZXQoKTtcbiAgICAgIGlmIChhbGlnbiA9PT0gXCJhdXRvXCIpIHtcbiAgICAgICAgaWYgKHRvT2Zmc2V0IDw9IHNjcm9sbE9mZnNldCkge1xuICAgICAgICAgIGFsaWduID0gXCJzdGFydFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHRvT2Zmc2V0ID49IHNjcm9sbE9mZnNldCArIHNpemUpIHtcbiAgICAgICAgICBhbGlnbiA9IFwiZW5kXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxpZ24gPSBcInN0YXJ0XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhbGlnbiA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgIHRvT2Zmc2V0ID0gdG9PZmZzZXQ7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSBcImVuZFwiKSB7XG4gICAgICAgIHRvT2Zmc2V0ID0gdG9PZmZzZXQgLSBzaXplO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gXCJjZW50ZXJcIikge1xuICAgICAgICB0b09mZnNldCA9IHRvT2Zmc2V0IC0gc2l6ZSAvIDI7XG4gICAgICB9XG4gICAgICBjb25zdCBzY3JvbGxTaXplUHJvcCA9IHRoaXMub3B0aW9ucy5ob3Jpem9udGFsID8gXCJzY3JvbGxXaWR0aFwiIDogXCJzY3JvbGxIZWlnaHRcIjtcbiAgICAgIGNvbnN0IHNjcm9sbFNpemUgPSB0aGlzLnNjcm9sbEVsZW1lbnQgPyBcImRvY3VtZW50XCIgaW4gdGhpcy5zY3JvbGxFbGVtZW50ID8gdGhpcy5zY3JvbGxFbGVtZW50LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtzY3JvbGxTaXplUHJvcF0gOiB0aGlzLnNjcm9sbEVsZW1lbnRbc2Nyb2xsU2l6ZVByb3BdIDogMDtcbiAgICAgIGNvbnN0IG1heE9mZnNldCA9IHNjcm9sbFNpemUgLSBzaXplO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKG1heE9mZnNldCwgdG9PZmZzZXQpLCAwKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0T2Zmc2V0Rm9ySW5kZXggPSAoaW5kZXgsIGFsaWduID0gXCJhdXRvXCIpID0+IHtcbiAgICAgIGluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIHRoaXMub3B0aW9ucy5jb3VudCAtIDEpKTtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLm1lYXN1cmVtZW50c0NhY2hlW2luZGV4XTtcbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5nZXRTY3JvbGxPZmZzZXQoKTtcbiAgICAgIGlmIChhbGlnbiA9PT0gXCJhdXRvXCIpIHtcbiAgICAgICAgaWYgKGl0ZW0uZW5kID49IHNjcm9sbE9mZnNldCArIHNpemUgLSB0aGlzLm9wdGlvbnMuc2Nyb2xsUGFkZGluZ0VuZCkge1xuICAgICAgICAgIGFsaWduID0gXCJlbmRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLnN0YXJ0IDw9IHNjcm9sbE9mZnNldCArIHRoaXMub3B0aW9ucy5zY3JvbGxQYWRkaW5nU3RhcnQpIHtcbiAgICAgICAgICBhbGlnbiA9IFwic3RhcnRcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW3Njcm9sbE9mZnNldCwgYWxpZ25dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB0b09mZnNldCA9IGFsaWduID09PSBcImVuZFwiID8gaXRlbS5lbmQgKyB0aGlzLm9wdGlvbnMuc2Nyb2xsUGFkZGluZ0VuZCA6IGl0ZW0uc3RhcnQgLSB0aGlzLm9wdGlvbnMuc2Nyb2xsUGFkZGluZ1N0YXJ0O1xuICAgICAgcmV0dXJuIFt0aGlzLmdldE9mZnNldEZvckFsaWdubWVudCh0b09mZnNldCwgYWxpZ24pLCBhbGlnbl07XG4gICAgfTtcbiAgICB0aGlzLmlzRHluYW1pY01vZGUgPSAoKSA9PiB0aGlzLmVsZW1lbnRzQ2FjaGUuc2l6ZSA+IDA7XG4gICAgdGhpcy5jYW5jZWxTY3JvbGxUb0luZGV4ID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc2Nyb2xsVG9JbmRleFRpbWVvdXRJZCAhPT0gbnVsbCAmJiB0aGlzLnRhcmdldFdpbmRvdykge1xuICAgICAgICB0aGlzLnRhcmdldFdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkKTtcbiAgICAgICAgdGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc2Nyb2xsVG9PZmZzZXQgPSAodG9PZmZzZXQsIHsgYWxpZ24gPSBcInN0YXJ0XCIsIGJlaGF2aW9yIH0gPSB7fSkgPT4ge1xuICAgICAgdGhpcy5jYW5jZWxTY3JvbGxUb0luZGV4KCk7XG4gICAgICBpZiAoYmVoYXZpb3IgPT09IFwic21vb3RoXCIgJiYgdGhpcy5pc0R5bmFtaWNNb2RlKCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiVGhlIGBzbW9vdGhgIHNjcm9sbCBiZWhhdmlvciBpcyBub3QgZnVsbHkgc3VwcG9ydGVkIHdpdGggZHluYW1pYyBzaXplLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zY3JvbGxUb09mZnNldCh0aGlzLmdldE9mZnNldEZvckFsaWdubWVudCh0b09mZnNldCwgYWxpZ24pLCB7XG4gICAgICAgIGFkanVzdG1lbnRzOiB2b2lkIDAsXG4gICAgICAgIGJlaGF2aW9yXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuc2Nyb2xsVG9JbmRleCA9IChpbmRleCwgeyBhbGlnbjogaW5pdGlhbEFsaWduID0gXCJhdXRvXCIsIGJlaGF2aW9yIH0gPSB7fSkgPT4ge1xuICAgICAgaW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgdGhpcy5vcHRpb25zLmNvdW50IC0gMSkpO1xuICAgICAgdGhpcy5jYW5jZWxTY3JvbGxUb0luZGV4KCk7XG4gICAgICBpZiAoYmVoYXZpb3IgPT09IFwic21vb3RoXCIgJiYgdGhpcy5pc0R5bmFtaWNNb2RlKCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiVGhlIGBzbW9vdGhgIHNjcm9sbCBiZWhhdmlvciBpcyBub3QgZnVsbHkgc3VwcG9ydGVkIHdpdGggZHluYW1pYyBzaXplLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBvZmZzZXRBbmRBbGlnbiA9IHRoaXMuZ2V0T2Zmc2V0Rm9ySW5kZXgoaW5kZXgsIGluaXRpYWxBbGlnbik7XG4gICAgICBpZiAoIW9mZnNldEFuZEFsaWduKSByZXR1cm47XG4gICAgICBjb25zdCBbb2Zmc2V0LCBhbGlnbl0gPSBvZmZzZXRBbmRBbGlnbjtcbiAgICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0KG9mZnNldCwgeyBhZGp1c3RtZW50czogdm9pZCAwLCBiZWhhdmlvciB9KTtcbiAgICAgIGlmIChiZWhhdmlvciAhPT0gXCJzbW9vdGhcIiAmJiB0aGlzLmlzRHluYW1pY01vZGUoKSAmJiB0aGlzLnRhcmdldFdpbmRvdykge1xuICAgICAgICB0aGlzLnNjcm9sbFRvSW5kZXhUaW1lb3V0SWQgPSB0aGlzLnRhcmdldFdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnNjcm9sbFRvSW5kZXhUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnRJbkRPTSA9IHRoaXMuZWxlbWVudHNDYWNoZS5oYXMoXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZ2V0SXRlbUtleShpbmRleClcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChlbGVtZW50SW5ET00pIHtcbiAgICAgICAgICAgIGNvbnN0IFtsYXRlc3RPZmZzZXRdID0gbm90VW5kZWZpbmVkKFxuICAgICAgICAgICAgICB0aGlzLmdldE9mZnNldEZvckluZGV4KGluZGV4LCBhbGlnbilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIWFwcHJveEVxdWFsKGxhdGVzdE9mZnNldCwgdGhpcy5nZXRTY3JvbGxPZmZzZXQoKSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0luZGV4KGluZGV4LCB7IGFsaWduLCBiZWhhdmlvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0luZGV4KGluZGV4LCB7IGFsaWduLCBiZWhhdmlvciB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zY3JvbGxCeSA9IChkZWx0YSwgeyBiZWhhdmlvciB9ID0ge30pID0+IHtcbiAgICAgIHRoaXMuY2FuY2VsU2Nyb2xsVG9JbmRleCgpO1xuICAgICAgaWYgKGJlaGF2aW9yID09PSBcInNtb290aFwiICYmIHRoaXMuaXNEeW5hbWljTW9kZSgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlRoZSBgc21vb3RoYCBzY3JvbGwgYmVoYXZpb3IgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCB3aXRoIGR5bmFtaWMgc2l6ZS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2Nyb2xsVG9PZmZzZXQodGhpcy5nZXRTY3JvbGxPZmZzZXQoKSArIGRlbHRhLCB7XG4gICAgICAgIGFkanVzdG1lbnRzOiB2b2lkIDAsXG4gICAgICAgIGJlaGF2aW9yXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0VG90YWxTaXplID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgbWVhc3VyZW1lbnRzID0gdGhpcy5nZXRNZWFzdXJlbWVudHMoKTtcbiAgICAgIGxldCBlbmQ7XG4gICAgICBpZiAobWVhc3VyZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBlbmQgPSB0aGlzLm9wdGlvbnMucGFkZGluZ1N0YXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gdGhpcy5vcHRpb25zLmxhbmVzID09PSAxID8gKChfYSA9IG1lYXN1cmVtZW50c1ttZWFzdXJlbWVudHMubGVuZ3RoIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5lbmQpID8/IDAgOiBNYXRoLm1heChcbiAgICAgICAgICAuLi5tZWFzdXJlbWVudHMuc2xpY2UoLXRoaXMub3B0aW9ucy5sYW5lcykubWFwKChtKSA9PiBtLmVuZClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgICAgZW5kIC0gdGhpcy5vcHRpb25zLnNjcm9sbE1hcmdpbiArIHRoaXMub3B0aW9ucy5wYWRkaW5nRW5kLFxuICAgICAgICAwXG4gICAgICApO1xuICAgIH07XG4gICAgdGhpcy5fc2Nyb2xsVG9PZmZzZXQgPSAob2Zmc2V0LCB7XG4gICAgICBhZGp1c3RtZW50cyxcbiAgICAgIGJlaGF2aW9yXG4gICAgfSkgPT4ge1xuICAgICAgdGhpcy5vcHRpb25zLnNjcm9sbFRvRm4ob2Zmc2V0LCB7IGJlaGF2aW9yLCBhZGp1c3RtZW50cyB9LCB0aGlzKTtcbiAgICB9O1xuICAgIHRoaXMubWVhc3VyZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuaXRlbVNpemVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICB0aGlzLm5vdGlmeShmYWxzZSk7XG4gICAgfTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0cyk7XG4gIH1cbn1cbmNvbnN0IGZpbmROZWFyZXN0QmluYXJ5U2VhcmNoID0gKGxvdywgaGlnaCwgZ2V0Q3VycmVudFZhbHVlLCB2YWx1ZSkgPT4ge1xuICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICBjb25zdCBtaWRkbGUgPSAobG93ICsgaGlnaCkgLyAyIHwgMDtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBnZXRDdXJyZW50VmFsdWUobWlkZGxlKTtcbiAgICBpZiAoY3VycmVudFZhbHVlIDwgdmFsdWUpIHtcbiAgICAgIGxvdyA9IG1pZGRsZSArIDE7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50VmFsdWUgPiB2YWx1ZSkge1xuICAgICAgaGlnaCA9IG1pZGRsZSAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgfVxuICB9XG4gIGlmIChsb3cgPiAwKSB7XG4gICAgcmV0dXJuIGxvdyAtIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5mdW5jdGlvbiBjYWxjdWxhdGVSYW5nZSh7XG4gIG1lYXN1cmVtZW50cyxcbiAgb3V0ZXJTaXplLFxuICBzY3JvbGxPZmZzZXRcbn0pIHtcbiAgY29uc3QgY291bnQgPSBtZWFzdXJlbWVudHMubGVuZ3RoIC0gMTtcbiAgY29uc3QgZ2V0T2Zmc2V0ID0gKGluZGV4KSA9PiBtZWFzdXJlbWVudHNbaW5kZXhdLnN0YXJ0O1xuICBjb25zdCBzdGFydEluZGV4ID0gZmluZE5lYXJlc3RCaW5hcnlTZWFyY2goMCwgY291bnQsIGdldE9mZnNldCwgc2Nyb2xsT2Zmc2V0KTtcbiAgbGV0IGVuZEluZGV4ID0gc3RhcnRJbmRleDtcbiAgd2hpbGUgKGVuZEluZGV4IDwgY291bnQgJiYgbWVhc3VyZW1lbnRzW2VuZEluZGV4XS5lbmQgPCBzY3JvbGxPZmZzZXQgKyBvdXRlclNpemUpIHtcbiAgICBlbmRJbmRleCsrO1xuICB9XG4gIHJldHVybiB7IHN0YXJ0SW5kZXgsIGVuZEluZGV4IH07XG59XG5leHBvcnQge1xuICBWaXJ0dWFsaXplcixcbiAgYXBwcm94RXF1YWwsXG4gIGRlYm91bmNlLFxuICBkZWZhdWx0S2V5RXh0cmFjdG9yLFxuICBkZWZhdWx0UmFuZ2VFeHRyYWN0b3IsXG4gIGVsZW1lbnRTY3JvbGwsXG4gIG1lYXN1cmVFbGVtZW50LFxuICBtZW1vLFxuICBub3RVbmRlZmluZWQsXG4gIG9ic2VydmVFbGVtZW50T2Zmc2V0LFxuICBvYnNlcnZlRWxlbWVudFJlY3QsXG4gIG9ic2VydmVXaW5kb3dPZmZzZXQsXG4gIG9ic2VydmVXaW5kb3dSZWN0LFxuICB3aW5kb3dTY3JvbGxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJkZWJvdW5jZSIsIm1lbW8iLCJub3RVbmRlZmluZWQiLCJhcHByb3hFcXVhbCIsImRlZmF1bHRLZXlFeHRyYWN0b3IiLCJpbmRleCIsImRlZmF1bHRSYW5nZUV4dHJhY3RvciIsInJhbmdlIiwic3RhcnQiLCJNYXRoIiwibWF4Iiwic3RhcnRJbmRleCIsIm92ZXJzY2FuIiwiZW5kIiwibWluIiwiZW5kSW5kZXgiLCJjb3VudCIsImFyciIsImkiLCJwdXNoIiwib2JzZXJ2ZUVsZW1lbnRSZWN0IiwiaW5zdGFuY2UiLCJjYiIsImVsZW1lbnQiLCJzY3JvbGxFbGVtZW50IiwidGFyZ2V0V2luZG93IiwiaGFuZGxlciIsInJlY3QiLCJ3aWR0aCIsImhlaWdodCIsInJvdW5kIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiUmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlciIsImVudHJpZXMiLCJlbnRyeSIsImJvcmRlckJveFNpemUiLCJib3giLCJpbmxpbmVTaXplIiwiYmxvY2tTaXplIiwib2JzZXJ2ZSIsInVub2JzZXJ2ZSIsImFkZEV2ZW50TGlzdGVuZXJPcHRpb25zIiwicGFzc2l2ZSIsIm9ic2VydmVXaW5kb3dSZWN0IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzdXBwb3J0c1Njcm9sbGVuZCIsIndpbmRvdyIsIm9ic2VydmVFbGVtZW50T2Zmc2V0Iiwib2Zmc2V0IiwiZmFsbGJhY2siLCJvcHRpb25zIiwidXNlU2Nyb2xsZW5kRXZlbnQiLCJpc1Njcm9sbGluZ1Jlc2V0RGVsYXkiLCJjcmVhdGVIYW5kbGVyIiwiaXNTY3JvbGxpbmciLCJob3Jpem9udGFsIiwiaXNSdGwiLCJlbmRIYW5kbGVyIiwib2JzZXJ2ZVdpbmRvd09mZnNldCIsIm1lYXN1cmVFbGVtZW50Iiwic2l6ZSIsIndpbmRvd1Njcm9sbCIsImFkanVzdG1lbnRzIiwiYmVoYXZpb3IiLCJfYSIsIl9iIiwidG9PZmZzZXQiLCJzY3JvbGxUbyIsImNhbGwiLCJlbGVtZW50U2Nyb2xsIiwiVmlydHVhbGl6ZXIiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJ1bnN1YnMiLCJzY3JvbGxUb0luZGV4VGltZW91dElkIiwibWVhc3VyZW1lbnRzQ2FjaGUiLCJpdGVtU2l6ZUNhY2hlIiwiTWFwIiwicGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzIiwic2Nyb2xsUmVjdCIsInNjcm9sbE9mZnNldCIsInNjcm9sbERpcmVjdGlvbiIsInNjcm9sbEFkanVzdG1lbnRzIiwiZWxlbWVudHNDYWNoZSIsIl9ybyIsImdldCIsImZvckVhY2giLCJfbWVhc3VyZUVsZW1lbnQiLCJ0YXJnZXQiLCJkaXNjb25uZWN0Iiwic2V0T3B0aW9ucyIsIm9wdHMyIiwiT2JqZWN0Iiwia2V5IiwidmFsdWUiLCJkZWJ1ZyIsImluaXRpYWxPZmZzZXQiLCJwYWRkaW5nU3RhcnQiLCJwYWRkaW5nRW5kIiwic2Nyb2xsUGFkZGluZ1N0YXJ0Iiwic2Nyb2xsUGFkZGluZ0VuZCIsImdldEl0ZW1LZXkiLCJyYW5nZUV4dHJhY3RvciIsIm9uQ2hhbmdlIiwiaW5pdGlhbFJlY3QiLCJzY3JvbGxNYXJnaW4iLCJnYXAiLCJpbmRleEF0dHJpYnV0ZSIsImluaXRpYWxNZWFzdXJlbWVudHNDYWNoZSIsImxhbmVzIiwiZW5hYmxlZCIsIm5vdGlmeSIsInN5bmMiLCJtYXliZU5vdGlmeSIsImNhbGN1bGF0ZVJhbmdlIiwicHJvY2VzcyIsImluaXRpYWxEZXBzIiwiY2xlYW51cCIsImZpbHRlciIsIkJvb2xlYW4iLCJkIiwiX2RpZE1vdW50IiwiX3dpbGxVcGRhdGUiLCJnZXRTY3JvbGxFbGVtZW50Iiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiY2FjaGVkIiwiX3Njcm9sbFRvT2Zmc2V0IiwiZ2V0U2Nyb2xsT2Zmc2V0IiwiZ2V0U2l6ZSIsImdldEZ1cnRoZXN0TWVhc3VyZW1lbnQiLCJtZWFzdXJlbWVudHMiLCJmdXJ0aGVzdE1lYXN1cmVtZW50c0ZvdW5kIiwiZnVydGhlc3RNZWFzdXJlbWVudHMiLCJtIiwibWVhc3VyZW1lbnQiLCJoYXMiLCJsYW5lIiwicHJldmlvdXNGdXJ0aGVzdE1lYXN1cmVtZW50Iiwic2V0IiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwic29ydCIsImEiLCJiIiwiZ2V0TWVhc3VyZW1lbnRPcHRpb25zIiwiZ2V0TWVhc3VyZW1lbnRzIiwiY2xlYXIiLCJsZW5ndGgiLCJpdGVtIiwic2xpY2UiLCJmdXJ0aGVzdE1lYXN1cmVtZW50IiwibWVhc3VyZWRTaXplIiwiZXN0aW1hdGVTaXplIiwib3V0ZXJTaXplIiwiZ2V0SW5kZXhlcyIsImluZGV4RnJvbUVsZW1lbnQiLCJub2RlIiwiYXR0cmlidXRlTmFtZSIsImluZGV4U3RyIiwiZ2V0QXR0cmlidXRlIiwiY29uc29sZSIsIndhcm4iLCJwYXJzZUludCIsInByZXZOb2RlIiwiaXNDb25uZWN0ZWQiLCJyZXNpemVJdGVtIiwiaXRlbVNpemUiLCJkZWx0YSIsInNob3VsZEFkanVzdFNjcm9sbFBvc2l0aW9uT25JdGVtU2l6ZUNoYW5nZSIsImluZm8iLCJkZWxldGUiLCJnZXRWaXJ0dWFsSXRlbXMiLCJpbmRleGVzIiwidmlydHVhbEl0ZW1zIiwiayIsImxlbiIsImdldFZpcnR1YWxJdGVtRm9yT2Zmc2V0IiwiZmluZE5lYXJlc3RCaW5hcnlTZWFyY2giLCJnZXRPZmZzZXRGb3JBbGlnbm1lbnQiLCJhbGlnbiIsInNjcm9sbFNpemVQcm9wIiwic2Nyb2xsU2l6ZSIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwibWF4T2Zmc2V0IiwiZ2V0T2Zmc2V0Rm9ySW5kZXgiLCJpc0R5bmFtaWNNb2RlIiwiY2FuY2VsU2Nyb2xsVG9JbmRleCIsImNsZWFyVGltZW91dCIsInNjcm9sbFRvT2Zmc2V0Iiwic2Nyb2xsVG9JbmRleCIsImluaXRpYWxBbGlnbiIsIm9mZnNldEFuZEFsaWduIiwic2V0VGltZW91dCIsImVsZW1lbnRJbkRPTSIsImxhdGVzdE9mZnNldCIsInNjcm9sbEJ5IiwiZ2V0VG90YWxTaXplIiwibWFwIiwic2Nyb2xsVG9GbiIsIm1lYXN1cmUiLCJsb3ciLCJoaWdoIiwiZ2V0Q3VycmVudFZhbHVlIiwibWlkZGxlIiwiY3VycmVudFZhbHVlIiwiZ2V0T2Zmc2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@tanstack+virtual-core@3.10.9/node_modules/@tanstack/virtual-core/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@tanstack+virtual-core@3.10.9/node_modules/@tanstack/virtual-core/dist/esm/utils.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@tanstack+virtual-core@3.10.9/node_modules/@tanstack/virtual-core/dist/esm/utils.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   approxEqual: () => (/* binding */ approxEqual),\n/* harmony export */   debounce: () => (/* binding */ debounce),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   notUndefined: () => (/* binding */ notUndefined)\n/* harmony export */ });\nfunction memo(getDeps, fn, opts) {\n    let deps = opts.initialDeps ?? [];\n    let result;\n    return ()=>{\n        var _a, _b, _c, _d;\n        let depTime;\n        if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();\n        const newDeps = getDeps();\n        const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index)=>deps[index] !== dep);\n        if (!depsChanged) {\n            return result;\n        }\n        deps = newDeps;\n        let resultTime;\n        if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();\n        result = fn(...newDeps);\n        if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {\n            const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n            const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n            const resultFpsPercentage = resultEndTime / 16;\n            const pad = (str, num)=>{\n                str = String(str);\n                while(str.length < num){\n                    str = \" \" + str;\n                }\n                return str;\n            };\n            console.info(`%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);\n        }\n        (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);\n        return result;\n    };\n}\nfunction notUndefined(value, msg) {\n    if (value === void 0) {\n        throw new Error(`Unexpected undefined${msg ? `: ${msg}` : \"\"}`);\n    } else {\n        return value;\n    }\n}\nconst approxEqual = (a, b)=>Math.abs(a - b) < 1;\nconst debounce = (targetWindow, fn, ms)=>{\n    let timeoutId;\n    return function(...args) {\n        targetWindow.clearTimeout(timeoutId);\n        timeoutId = targetWindow.setTimeout(()=>fn.apply(this, args), ms);\n    };\n};\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRhbnN0YWNrK3ZpcnR1YWwtY29yZUAzLjEwLjkvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay92aXJ0dWFsLWNvcmUvZGlzdC9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLFNBQVNBLEtBQUtDLE9BQU8sRUFBRUMsRUFBRSxFQUFFQyxJQUFJO0lBQzdCLElBQUlDLE9BQU9ELEtBQUtFLFdBQVcsSUFBSSxFQUFFO0lBQ2pDLElBQUlDO0lBQ0osT0FBTztRQUNMLElBQUlDLElBQUlDLElBQUlDLElBQUlDO1FBQ2hCLElBQUlDO1FBQ0osSUFBSVIsS0FBS1MsR0FBRyxJQUFLLEVBQUNMLEtBQUtKLEtBQUtVLEtBQUssS0FBSyxPQUFPLEtBQUssSUFBSU4sR0FBR08sSUFBSSxDQUFDWCxLQUFJLEdBQUlRLFVBQVVJLEtBQUtDLEdBQUc7UUFDeEYsTUFBTUMsVUFBVWhCO1FBQ2hCLE1BQU1pQixjQUFjRCxRQUFRRSxNQUFNLEtBQUtmLEtBQUtlLE1BQU0sSUFBSUYsUUFBUUcsSUFBSSxDQUFDLENBQUNDLEtBQUtDLFFBQVVsQixJQUFJLENBQUNrQixNQUFNLEtBQUtEO1FBQ25HLElBQUksQ0FBQ0gsYUFBYTtZQUNoQixPQUFPWjtRQUNUO1FBQ0FGLE9BQU9hO1FBQ1AsSUFBSU07UUFDSixJQUFJcEIsS0FBS1MsR0FBRyxJQUFLLEVBQUNKLEtBQUtMLEtBQUtVLEtBQUssS0FBSyxPQUFPLEtBQUssSUFBSUwsR0FBR00sSUFBSSxDQUFDWCxLQUFJLEdBQUlvQixhQUFhUixLQUFLQyxHQUFHO1FBQzNGVixTQUFTSixNQUFNZTtRQUNmLElBQUlkLEtBQUtTLEdBQUcsSUFBSyxFQUFDSCxLQUFLTixLQUFLVSxLQUFLLEtBQUssT0FBTyxLQUFLLElBQUlKLEdBQUdLLElBQUksQ0FBQ1gsS0FBSSxHQUFJO1lBQ3BFLE1BQU1xQixhQUFhQyxLQUFLQyxLQUFLLENBQUMsQ0FBQ1gsS0FBS0MsR0FBRyxLQUFLTCxPQUFNLElBQUssT0FBTztZQUM5RCxNQUFNZ0IsZ0JBQWdCRixLQUFLQyxLQUFLLENBQUMsQ0FBQ1gsS0FBS0MsR0FBRyxLQUFLTyxVQUFTLElBQUssT0FBTztZQUNwRSxNQUFNSyxzQkFBc0JELGdCQUFnQjtZQUM1QyxNQUFNRSxNQUFNLENBQUNDLEtBQUtDO2dCQUNoQkQsTUFBTUUsT0FBT0Y7Z0JBQ2IsTUFBT0EsSUFBSVgsTUFBTSxHQUFHWSxJQUFLO29CQUN2QkQsTUFBTSxNQUFNQTtnQkFDZDtnQkFDQSxPQUFPQTtZQUNUO1lBQ0FHLFFBQVFDLElBQUksQ0FDVixDQUFDLElBQUksRUFBRUwsSUFBSUYsZUFBZSxHQUFHLEVBQUUsRUFBRUUsSUFBSUwsWUFBWSxHQUFHLEdBQUcsQ0FBQyxFQUN4RCxDQUFDOzs7dUJBR2MsRUFBRUMsS0FBS1UsR0FBRyxDQUN2QixHQUNBVixLQUFLVyxHQUFHLENBQUMsTUFBTSxNQUFNUixxQkFBcUIsTUFDMUMsY0FBYyxDQUFDLEVBQ2pCekIsUUFBUSxPQUFPLEtBQUssSUFBSUEsS0FBS1MsR0FBRztRQUVwQztRQUNDRixDQUFBQSxLQUFLUCxRQUFRLE9BQU8sS0FBSyxJQUFJQSxLQUFLa0MsUUFBUSxLQUFLLE9BQU8sS0FBSyxJQUFJM0IsR0FBR0ksSUFBSSxDQUFDWCxNQUFNRztRQUM5RSxPQUFPQTtJQUNUO0FBQ0Y7QUFDQSxTQUFTZ0MsYUFBYUMsS0FBSyxFQUFFQyxHQUFHO0lBQzlCLElBQUlELFVBQVUsS0FBSyxHQUFHO1FBQ3BCLE1BQU0sSUFBSUUsTUFBTSxDQUFDLG9CQUFvQixFQUFFRCxNQUFNLENBQUMsRUFBRSxFQUFFQSxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUM7SUFDaEUsT0FBTztRQUNMLE9BQU9EO0lBQ1Q7QUFDRjtBQUNBLE1BQU1HLGNBQWMsQ0FBQ0MsR0FBR0MsSUFBTW5CLEtBQUtvQixHQUFHLENBQUNGLElBQUlDLEtBQUs7QUFDaEQsTUFBTUUsV0FBVyxDQUFDQyxjQUFjN0MsSUFBSThDO0lBQ2xDLElBQUlDO0lBQ0osT0FBTyxTQUFTLEdBQUdDLElBQUk7UUFDckJILGFBQWFJLFlBQVksQ0FBQ0Y7UUFDMUJBLFlBQVlGLGFBQWFLLFVBQVUsQ0FBQyxJQUFNbEQsR0FBR21ELEtBQUssQ0FBQyxJQUFJLEVBQUVILE9BQU9GO0lBQ2xFO0FBQ0Y7QUFNRSxDQUNGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hpbWFsYXlhcy14Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0YW5zdGFjayt2aXJ0dWFsLWNvcmVAMy4xMC45L25vZGVfbW9kdWxlcy9AdGFuc3RhY2svdmlydHVhbC1jb3JlL2Rpc3QvZXNtL3V0aWxzLmpzPzRjZjMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbWVtbyhnZXREZXBzLCBmbiwgb3B0cykge1xuICBsZXQgZGVwcyA9IG9wdHMuaW5pdGlhbERlcHMgPz8gW107XG4gIGxldCByZXN1bHQ7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGxldCBkZXBUaW1lO1xuICAgIGlmIChvcHRzLmtleSAmJiAoKF9hID0gb3B0cy5kZWJ1ZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0cykpKSBkZXBUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBuZXdEZXBzID0gZ2V0RGVwcygpO1xuICAgIGNvbnN0IGRlcHNDaGFuZ2VkID0gbmV3RGVwcy5sZW5ndGggIT09IGRlcHMubGVuZ3RoIHx8IG5ld0RlcHMuc29tZSgoZGVwLCBpbmRleCkgPT4gZGVwc1tpbmRleF0gIT09IGRlcCk7XG4gICAgaWYgKCFkZXBzQ2hhbmdlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZGVwcyA9IG5ld0RlcHM7XG4gICAgbGV0IHJlc3VsdFRpbWU7XG4gICAgaWYgKG9wdHMua2V5ICYmICgoX2IgPSBvcHRzLmRlYnVnKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChvcHRzKSkpIHJlc3VsdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHJlc3VsdCA9IGZuKC4uLm5ld0RlcHMpO1xuICAgIGlmIChvcHRzLmtleSAmJiAoKF9jID0gb3B0cy5kZWJ1ZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwob3B0cykpKSB7XG4gICAgICBjb25zdCBkZXBFbmRUaW1lID0gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIGRlcFRpbWUpICogMTAwKSAvIDEwMDtcbiAgICAgIGNvbnN0IHJlc3VsdEVuZFRpbWUgPSBNYXRoLnJvdW5kKChEYXRlLm5vdygpIC0gcmVzdWx0VGltZSkgKiAxMDApIC8gMTAwO1xuICAgICAgY29uc3QgcmVzdWx0RnBzUGVyY2VudGFnZSA9IHJlc3VsdEVuZFRpbWUgLyAxNjtcbiAgICAgIGNvbnN0IHBhZCA9IChzdHIsIG51bSkgPT4ge1xuICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBudW0pIHtcbiAgICAgICAgICBzdHIgPSBcIiBcIiArIHN0cjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfTtcbiAgICAgIGNvbnNvbGUuaW5mbyhcbiAgICAgICAgYCVj4o+xICR7cGFkKHJlc3VsdEVuZFRpbWUsIDUpfSAvJHtwYWQoZGVwRW5kVGltZSwgNSl9IG1zYCxcbiAgICAgICAgYFxuICAgICAgICAgICAgZm9udC1zaXplOiAuNnJlbTtcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgICAgY29sb3I6IGhzbCgke01hdGgubWF4KFxuICAgICAgICAgIDAsXG4gICAgICAgICAgTWF0aC5taW4oMTIwIC0gMTIwICogcmVzdWx0RnBzUGVyY2VudGFnZSwgMTIwKVxuICAgICAgICApfWRlZyAxMDAlIDMxJSk7YCxcbiAgICAgICAgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5rZXlcbiAgICAgICk7XG4gICAgfVxuICAgIChfZCA9IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMub25DaGFuZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfZC5jYWxsKG9wdHMsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vdFVuZGVmaW5lZCh2YWx1ZSwgbXNnKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHVuZGVmaW5lZCR7bXNnID8gYDogJHttc2d9YCA6IFwiXCJ9YCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5jb25zdCBhcHByb3hFcXVhbCA9IChhLCBiKSA9PiBNYXRoLmFicyhhIC0gYikgPCAxO1xuY29uc3QgZGVib3VuY2UgPSAodGFyZ2V0V2luZG93LCBmbiwgbXMpID0+IHtcbiAgbGV0IHRpbWVvdXRJZDtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICB0YXJnZXRXaW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgdGltZW91dElkID0gdGFyZ2V0V2luZG93LnNldFRpbWVvdXQoKCkgPT4gZm4uYXBwbHkodGhpcywgYXJncyksIG1zKTtcbiAgfTtcbn07XG5leHBvcnQge1xuICBhcHByb3hFcXVhbCxcbiAgZGVib3VuY2UsXG4gIG1lbW8sXG4gIG5vdFVuZGVmaW5lZFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbIm1lbW8iLCJnZXREZXBzIiwiZm4iLCJvcHRzIiwiZGVwcyIsImluaXRpYWxEZXBzIiwicmVzdWx0IiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJkZXBUaW1lIiwia2V5IiwiZGVidWciLCJjYWxsIiwiRGF0ZSIsIm5vdyIsIm5ld0RlcHMiLCJkZXBzQ2hhbmdlZCIsImxlbmd0aCIsInNvbWUiLCJkZXAiLCJpbmRleCIsInJlc3VsdFRpbWUiLCJkZXBFbmRUaW1lIiwiTWF0aCIsInJvdW5kIiwicmVzdWx0RW5kVGltZSIsInJlc3VsdEZwc1BlcmNlbnRhZ2UiLCJwYWQiLCJzdHIiLCJudW0iLCJTdHJpbmciLCJjb25zb2xlIiwiaW5mbyIsIm1heCIsIm1pbiIsIm9uQ2hhbmdlIiwibm90VW5kZWZpbmVkIiwidmFsdWUiLCJtc2ciLCJFcnJvciIsImFwcHJveEVxdWFsIiwiYSIsImIiLCJhYnMiLCJkZWJvdW5jZSIsInRhcmdldFdpbmRvdyIsIm1zIiwidGltZW91dElkIiwiYXJncyIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJhcHBseSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@tanstack+virtual-core@3.10.9/node_modules/@tanstack/virtual-core/dist/esm/utils.js\n");

/***/ })

};
;